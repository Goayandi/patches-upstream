From 53c438235aaae2f04463a1b3f5442db1f9cabbc6 Mon Sep 17 00:00:00 2001
From: "pi-cheng.chen" <pi-cheng.chen@linaro.org>
Date: Tue, 10 Feb 2015 17:37:41 +0800
Subject: [PATCH 09/11] cpufreq-dt: add intermediate frequency support

Signed-off-by: pi-cheng.chen <pi-cheng.chen@linaro.org>
---
 drivers/cpufreq/cpufreq-dt.c | 137 ++++++++++++++++++++++++++++++++++++++++++-
 include/linux/cpufreq-dt.h   |   7 +++
 2 files changed, 142 insertions(+), 2 deletions(-)

diff --git a/drivers/cpufreq/cpufreq-dt.c b/drivers/cpufreq/cpufreq-dt.c
index f56147a..0c99ae68 100644
--- a/drivers/cpufreq/cpufreq-dt.c
+++ b/drivers/cpufreq/cpufreq-dt.c
@@ -28,8 +28,11 @@
 #include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 #include <linux/thermal.h>
+#include <linux/clk-provider.h>
 
 struct private_data {
+	struct clk *inter_clk;
+	struct clk *orig_clk;
 	struct device *cpu_dev;
 	struct regulator *cpu_reg;
 	struct thermal_cooling_device *cdev;
@@ -40,7 +43,7 @@ static int set_target(struct cpufreq_policy *policy, unsigned int index)
 {
 	struct dev_pm_opp *opp;
 	struct cpufreq_frequency_table *freq_table = policy->freq_table;
-	struct clk *cpu_clk = policy->clk;
+	struct clk *cpu_clk;
 	struct private_data *priv = policy->driver_data;
 	struct device *cpu_dev = priv->cpu_dev;
 	struct regulator *cpu_reg = priv->cpu_reg;
@@ -49,6 +52,11 @@ static int set_target(struct cpufreq_policy *policy, unsigned int index)
 	long freq_Hz, freq_exact;
 	int ret;
 
+	if (priv->inter_clk)
+		cpu_clk = priv->orig_clk;
+	else
+		cpu_clk = policy->clk;
+
 	freq_Hz = clk_round_rate(cpu_clk, freq_table[index].frequency * 1000);
 	if (freq_Hz <= 0)
 		freq_Hz = freq_table[index].frequency * 1000;
@@ -99,13 +107,114 @@ static int set_target(struct cpufreq_policy *policy, unsigned int index)
 		return ret;
 	}
 
+	if (priv->inter_clk) {
+		ret = clk_set_parent(policy->clk, priv->orig_clk);
+		if (ret) {
+			dev_err(cpu_dev, "failed to set clock parent: %d\n",
+				ret);
+			if (!IS_ERR(cpu_reg) && volt_old > 0) {
+				regulator_set_voltage_tol(cpu_reg, volt_old,
+							  tol);
+				return ret;
+			}
+		}
+		clk_disable_unprepare(priv->orig_clk); // problem here
+	}
+
 	/* scaling down?  scale voltage after frequency */
 	if (!IS_ERR(cpu_reg) && new_freq < old_freq) {
 		ret = regulator_set_voltage_tol(cpu_reg, volt, tol);
 		if (ret) {
 			dev_err(cpu_dev, "failed to scale voltage down: %d\n",
 				ret);
-			clk_set_rate(cpu_clk, old_freq * 1000);
+			if (!priv->inter_clk) {
+				clk_set_rate(cpu_clk, old_freq * 1000);
+			} else {
+				clk_prepare_enable(priv->orig_clk);
+				clk_set_parent(policy->clk, priv->inter_clk);
+			}
+		}
+	}
+
+	return ret;
+}
+
+static unsigned int get_intermediate(struct cpufreq_policy *policy, unsigned int index)
+{
+	struct private_data *priv = policy->driver_data;
+	struct clk *parent;
+
+	if (!priv->inter_clk)
+		return 0;
+
+	parent = clk_get_parent(policy->clk);
+	if (parent == priv->inter_clk)
+		return 0;
+
+	return clk_get_rate(priv->inter_clk) / 1000;
+}
+
+static int target_intermediate(struct cpufreq_policy *policy,
+			       unsigned int index)
+{
+	struct private_data *priv = policy->driver_data;
+	struct dev_pm_opp *opp;
+	struct device *cpu_dev = priv->cpu_dev;
+	struct regulator *cpu_reg = priv->cpu_reg;
+	unsigned long volt = 0, volt_old = 0, tol = 0;
+	unsigned long ifreq_khz, ifreq_hz;
+	int ret;
+	struct clk *parent;
+
+	ifreq_hz = clk_get_rate(priv->inter_clk);
+	ifreq_khz = ifreq_hz / 1000;
+
+	if (!IS_ERR(cpu_reg)) {
+		rcu_read_lock();
+		opp = dev_pm_opp_find_freq_ceil(cpu_dev, &ifreq_hz);
+		if (IS_ERR(opp)) {
+			rcu_read_unlock();
+			dev_err(cpu_dev, "failed to find OPP for %ld\n",
+				ifreq_hz);
+			return PTR_ERR(opp);
+		}
+		volt = dev_pm_opp_get_voltage(opp);
+		rcu_read_unlock();
+		tol = volt * priv->voltage_tolerance / 100;
+		volt_old = regulator_get_voltage(cpu_reg);
+	}
+
+	clk_prepare_enable(priv->orig_clk);
+
+	if (!IS_ERR(cpu_reg) && policy->cur < ifreq_khz) {
+		ret = regulator_set_voltage_tol(cpu_reg, volt, tol);
+		if (ret) {
+			dev_err(cpu_dev, "failed to scale voltage up: %d\n",
+				ret);
+			return ret;
+		}
+	}
+
+	parent = clk_get_parent(policy->clk);
+
+	ret = clk_set_parent(policy->clk, priv->inter_clk);
+	if (ret) {
+		clk_disable_unprepare(priv->orig_clk);
+		dev_err(cpu_dev, "failed to set clock parent: %d\n", ret);
+		if (!IS_ERR(cpu_reg) && volt_old > 0)
+			regulator_set_voltage_tol(cpu_reg, volt_old, tol);
+		return ret;
+	}
+
+	parent = clk_get_parent(policy->clk);
+
+	if (!IS_ERR(cpu_reg) && ifreq_khz < policy->cur) {
+		ret = regulator_set_voltage_tol(cpu_reg, volt, tol);
+		if (ret) {
+			dev_err(cpu_dev, "failed to scale voltage down: %d\n",
+				ret);
+			clk_set_parent(policy->clk, priv->orig_clk);
+			clk_disable_unprepare(priv->orig_clk);
 		}
 	}
 
@@ -177,6 +286,7 @@ try_again:
 		*cdev = cpu_dev;
 		*creg = cpu_reg;
 		*cclk = cpu_clk;
+		clk_prepare_enable(cpu_clk);
 	}
 
 	return ret;
@@ -285,6 +395,25 @@ static int cpufreq_init(struct cpufreq_policy *policy)
 	pd = cpufreq_get_driver_data();
 	if (!pd || !pd->independent_clocks)
 		cpumask_setall(policy->cpus);
+	else if (pd && !list_empty(&pd->domain_list)) {
+		struct list_head *domain_node;
+		struct cpufreq_cpu_domain *domain;
+
+		list_for_each(domain_node, &pd->domain_list) {
+			domain = container_of(domain_node,
+					      struct cpufreq_cpu_domain, node);
+			if (!cpumask_test_cpu(policy->cpu, &domain->cpus))
+				continue;
+
+			if (domain->inter_clk) {
+				priv->inter_clk = domain->inter_clk;
+				priv->orig_clk = clk_get_parent(cpu_clk);
+				clk_prepare_enable(priv->orig_clk);
+			}
+			cpumask_copy(policy->cpus, &domain->cpus);
+			break;
+		}
+	}
 
 	of_node_put(np);
 
@@ -313,6 +442,8 @@ static int cpufreq_exit(struct cpufreq_policy *policy)
 		cpufreq_cooling_unregister(priv->cdev);
 	dev_pm_opp_free_cpufreq_table(priv->cpu_dev, &policy->freq_table);
 	of_free_opp_table(priv->cpu_dev);
+	if (priv->inter_clk)
+		clk_disable_unprepare(priv->inter_clk);
 	clk_put(policy->clk);
 	if (!IS_ERR(priv->cpu_reg))
 		regulator_put(priv->cpu_reg);
@@ -352,6 +483,8 @@ static struct cpufreq_driver dt_cpufreq_driver = {
 	.flags = CPUFREQ_STICKY | CPUFREQ_NEED_INITIAL_FREQ_CHECK,
 	.verify = cpufreq_generic_frequency_table_verify,
 	.target_index = set_target,
+	.get_intermediate = get_intermediate,
+	.target_intermediate = target_intermediate,
 	.get = cpufreq_generic_get,
 	.init = cpufreq_init,
 	.exit = cpufreq_exit,
diff --git a/include/linux/cpufreq-dt.h b/include/linux/cpufreq-dt.h
index 0414009..9b311a00 100644
--- a/include/linux/cpufreq-dt.h
+++ b/include/linux/cpufreq-dt.h
@@ -10,6 +10,12 @@
 #ifndef __CPUFREQ_DT_H__
 #define __CPUFREQ_DT_H__
 
+struct cpufreq_cpu_domain {
+	struct list_head node;
+	cpumask_t cpus;
+	struct clk *inter_clk;
+};
+
 struct cpufreq_dt_platform_data {
 	/*
 	 * True when each CPU has its own clock to control its
@@ -17,6 +23,7 @@ struct cpufreq_dt_platform_data {
 	 * clock.
 	 */
 	bool independent_clocks;
+	struct list_head domain_list;
 };
 
 #endif /* __CPUFREQ_DT_H__ */
-- 
1.9.1

